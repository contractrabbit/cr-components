{
  "name": "cumulative-density-filter",
  "type": "registry:ui",
  "description": "An interactive chart component that displays a cumulative distribution with a draggable threshold for filtering numeric data.",
  "dependencies": [
    "recharts"
  ],
  "devDependencies": [
    "@types/react",
    "@types/react-dom"
  ],
  "registryDependencies": [],
  "files": [
    {
      "path": "components/ui/cumulative-density-filter.tsx",
      "content": "/**\n * Cumulative Density Filter Component\n * \n * A responsive chart component that displays a cumulative distribution with \n * an interactive draggable threshold for filtering numeric data.\n * \n * @example\n * ```tsx\n * <CumulativeDensityFilter\n *   values={[10, 20, 30, 40, 50]}\n *   filterMode=\"lte\"\n *   onThresholdChange={(threshold, count) => console.log(threshold, count)}\n * />\n * ```\n */\n\nimport React, { useMemo, useRef, useState, useCallback, useEffect, ReactNode } from 'react';\nimport { computeTicks, getCountAtThreshold as utilGetCountAtThreshold, thresholdToPercentage } from '@/lib/cumulative-utils';\nimport {\n  Area,\n  AreaChart,\n  CartesianGrid,\n  ReferenceLine,\n  ResponsiveContainer,\n  Tooltip,\n  XAxis,\n  YAxis,\n} from 'recharts';\n\ninterface ThresholdLabelProps {\n  viewBox?: {\n    x?: number;\n    y?: number;\n    height?: number;\n  };\n  count: number;\n  total: number;\n  thresholdColor: string;\n  onMouseDown: (e?: React.MouseEvent) => void;\n  showLabel: boolean;\n}\n\n// Custom label component for the threshold line\nfunction ThresholdLabel({ viewBox, count, total, thresholdColor, onMouseDown, showLabel }: ThresholdLabelProps) {\n  if (!viewBox || !viewBox.x || !viewBox.y || !viewBox.height) return null;\n\n  const { x, y, height } = viewBox;\n\n  return (\n    <g>\n      {/* Count label at top (optional, since we render HTML overlay instead) */}\n      {showLabel && (\n        <g transform={`translate(${x}, ${y - 5})`} data-testid=\"cdf-threshold-label\">\n          <rect x=\"-30\" y=\"-20\" width=\"60\" height=\"20\" fill={thresholdColor} rx=\"4\" />\n          <text x=\"0\" y=\"-6\" textAnchor=\"middle\" fill=\"white\" fontSize=\"12\" fontWeight=\"500\">\n            {count} / {total}\n          </text>\n        </g>\n      )}\n\n      {/* Draggable handle at bottom - with larger invisible hitbox */}\n      <g transform={`translate(${x}, ${y + height})`}>\n        {/* Invisible larger hitbox for easier dragging */}\n        <rect\n          data-testid=\"cdf-handle-hitbox\"\n          x=\"-20\"\n          y=\"-10\"\n          width=\"40\"\n          height=\"40\"\n          fill=\"transparent\"\n          style={{ cursor: 'ew-resize', pointerEvents: 'all' }}\n          onMouseDown={(e) => onMouseDown(e as React.MouseEvent)}\n        />\n        {/* Visible handle */}\n        <rect\n          x=\"-14\"\n          y=\"0\"\n          width=\"28\"\n          height=\"24\"\n          fill={thresholdColor}\n          stroke=\"var(--background)\"\n          strokeWidth=\"2\"\n          rx=\"4\"\n          style={{ pointerEvents: 'none' }}\n        />\n        {/* Left-right arrow icon */}\n        <path\n          d=\"M -6 12 L -3 9 M -6 12 L -3 15 M -6 12 L 6 12 M 6 12 L 3 9 M 6 12 L 3 15\"\n          stroke=\"white\"\n          strokeWidth=\"1.5\"\n          strokeLinecap=\"round\"\n          strokeLinejoin=\"round\"\n          fill=\"none\"\n          style={{ pointerEvents: 'none' }}\n        />\n      </g>\n    </g>\n  );\n}\n\nexport interface CumulativeDensityFilterProps {\n  /** Array of numeric values to visualize */\n  values: number[];\n  /** Initial threshold position (defaults to midpoint) */\n  initialThreshold?: number;\n  /** Comparison operator for filtering */\n  filterMode?: 'lt' | 'lte' | 'gt' | 'gte';\n  /** Use logarithmic scale for X-axis */\n  logScale?: boolean;\n  /** Number of ticks on X-axis (defaults to auto) */\n  xAxisTicks?: number;\n  /** Color for the threshold marker and line (defaults to red #ef4444) */\n  thresholdColor?: string;\n  /** Callback fired when threshold changes */\n  onThresholdChange?: (threshold: number, count: number) => void;\n  /** Show the threshold count label above the line */\n  showThresholdLabel?: boolean;\n  /** Optional custom tooltip renderer. If provided, used as <Tooltip content={renderTooltip} /> */\n  renderTooltip?: (ctx: { active?: boolean; payload?: Array<{ value?: unknown }>; label?: string | number }) => ReactNode;\n  /** Height of the component in pixels */\n  height?: number;\n  /** Additional CSS classes */\n  className?: string;\n}\n\nexport function CumulativeDensityFilter({\n  values,\n  initialThreshold,\n  filterMode = 'lte',\n  logScale = false,\n  xAxisTicks,\n  thresholdColor = '#ef4444',\n  onThresholdChange,\n  renderTooltip,\n  showThresholdLabel = true,\n  height = 200,\n  className = '',\n}: CumulativeDensityFilterProps) {\n  const chartRef = useRef<HTMLDivElement>(null);\n  const [isDragging, setIsDragging] = useState(false);\n  const isDraggingRef = useRef(false);\n  const [containerWidth, setContainerWidth] = useState<number>(0);\n  \n  // Calculate cumulative distribution data\n  const { chartData, minValue, maxValue, sortedValues } = useMemo(() => {\n    if (!values.length) {\n      return { chartData: [], minValue: 0, maxValue: 0, sortedValues: [] as number[] };\n    }\n\n    const sorted = [...values].sort((a, b) => a - b);\n    const min = sorted[0]!;\n    const max = sorted[sorted.length - 1]!;\n\n    // Handle edge case where all values are the same\n    if (min === max) {\n      return {\n        chartData: [\n          { value: min, count: 0 },\n          { value: min, count: sorted.length },\n        ],\n        minValue: min,\n        maxValue: min,\n        sortedValues: sorted,\n      };\n    }\n\n    // Create bins for smooth distribution\n    const binCount = Math.min(100, sorted.length);\n    const binSize = (max - min) / binCount;\n    \n    const data: Array<{ value: number; count: number }> = [];\n    let currentIndex = 0;\n    \n    for (let i = 0; i <= binCount; i++) {\n      const binValue = min + i * binSize;\n\n      // Count all values up to this bin\n      while (currentIndex < sorted.length && sorted[currentIndex]! <= binValue) {\n        currentIndex++;\n      }\n\n      data.push({\n        value: binValue,\n        count: currentIndex,\n      });\n    }\n    \n    return { chartData: data, minValue: min, maxValue: max, sortedValues: sorted };\n  }, [values]);\n\n  // Initialize threshold\n  const [threshold, setThreshold] = useState(\n    initialThreshold ?? (minValue + maxValue) / 2\n  );\n\n  const getCountAtThreshold = useCallback((t: number): number => {\n    return utilGetCountAtThreshold(filterMode, sortedValues, t);\n  }, [sortedValues, filterMode]);\n\n  const currentCount = useMemo(() => getCountAtThreshold(threshold), [getCountAtThreshold, threshold]);\n\n  // Handle drag\n  const handleMouseDown = useCallback((e?: React.MouseEvent) => {\n    if (e) {\n      e.preventDefault();\n      e.stopPropagation();\n    }\n    isDraggingRef.current = true;\n    setIsDragging(true);\n  }, []);\n\n  const handleMouseMove = useCallback(\n    (e: MouseEvent | React.MouseEvent) => {\n      if (!isDraggingRef.current || !chartRef.current) return;\n\n      // Get chart dimensions for drag calculation\n      const svg = chartRef.current.querySelector('svg');\n      if (!svg) return;\n\n      // Find the actual plotting area\n      const plotEl =\n        svg.querySelector('.recharts-cartesian-grid-bg') ||\n        svg.querySelector('.recharts-cartesian-grid') ||\n        svg;\n\n      if (plotEl) {\n        const rect = (plotEl as Element).getBoundingClientRect();\n        const x = e.clientX - rect.left;\n        const percentage = Math.max(0, Math.min(1, x / rect.width || 1));\n\n        let newThreshold: number;\n        if (logScale && minValue > 0) {\n          // Log scale interpolation\n          const logMin = Math.log(minValue);\n          const logMax = Math.log(maxValue);\n          newThreshold = Math.exp(logMin + percentage * (logMax - logMin));\n        } else {\n          // Linear interpolation\n          newThreshold = minValue + percentage * (maxValue - minValue);\n        }\n\n        setThreshold(newThreshold);\n\n        const count = getCountAtThreshold(newThreshold);\n        onThresholdChange?.(newThreshold, count);\n      }\n    },\n    [minValue, maxValue, logScale, getCountAtThreshold, onThresholdChange]\n  );\n\n  const handleMouseUp = useCallback(() => {\n    isDraggingRef.current = false;\n    setIsDragging(false);\n  }, []);\n\n  // Mouse event listeners\n  React.useEffect(() => {\n    if (isDragging) {\n      window.addEventListener('mousemove', handleMouseMove);\n      window.addEventListener('mouseup', handleMouseUp);\n      return () => {\n        window.removeEventListener('mousemove', handleMouseMove);\n        window.removeEventListener('mouseup', handleMouseUp);\n      };\n    }\n    return undefined;\n  }, [isDragging, handleMouseMove, handleMouseUp]);\n\n  // Calculate custom X-axis ticks\n  const xAxisTickValues = useMemo(\n    () => computeTicks(minValue, maxValue, logScale, containerWidth, xAxisTicks),\n    [xAxisTicks, minValue, maxValue, logScale, containerWidth]\n  );\n\n  // Observe width to support auto tick calculation\n  useEffect(() => {\n    if (!chartRef.current) return;\n    const el = chartRef.current;\n    const update = () => {\n      const rect = el.getBoundingClientRect();\n      setContainerWidth(rect.width);\n    };\n    update();\n    const ro = new ResizeObserver(update);\n    ro.observe(el);\n    return () => ro.disconnect();\n  }, []);\n\n  // Calculate threshold position percentage\n  const thresholdPercentage = useMemo(\n    () => thresholdToPercentage(minValue, maxValue, threshold, logScale),\n    [threshold, minValue, maxValue, logScale]\n  );\n\n  if (!chartData.length) {\n    return (\n      <div className={`flex items-center justify-center ${className}`} style={{ height }}>\n        <p className=\"text-sm text-muted-foreground\">No data available</p>\n      </div>\n    );\n  }\n\n  return (\n    <div className={`relative ${className}`} style={{ height }}>\n      <div ref={chartRef} className=\"relative w-full h-full cd-filter-overflow\">\n        <ResponsiveContainer width=\"100%\" height=\"100%\">\n          <AreaChart\n            data={chartData}\n            margin={{ top: 30, right: 10, left: 10, bottom: 5 }}\n          >\n            <defs>\n              <linearGradient id=\"colorCount\" x1=\"0\" y1=\"0\" x2=\"0\" y2=\"1\">\n                <stop offset=\"5%\" stopColor=\"var(--primary)\" stopOpacity={0.3} />\n                <stop offset=\"95%\" stopColor=\"var(--primary)\" stopOpacity={0.05} />\n              </linearGradient>\n              \n              {/* Gradient mask based on filter mode */}\n              <linearGradient id=\"fillMask\" x1=\"0%\" y1=\"0\" x2=\"100%\" y2=\"0\">\n                {(filterMode === 'lt' || filterMode === 'lte') ? (\n                  <>\n                    <stop offset=\"0%\" stopOpacity=\"1\" />\n                    <stop offset={`${thresholdPercentage}%`} stopOpacity=\"1\" />\n                    <stop offset={`${thresholdPercentage}%`} stopOpacity=\"0\" />\n                    <stop offset=\"100%\" stopOpacity=\"0\" />\n                  </>\n                ) : (\n                  <>\n                    <stop offset=\"0%\" stopOpacity=\"0\" />\n                    <stop offset={`${thresholdPercentage}%`} stopOpacity=\"0\" />\n                    <stop offset={`${thresholdPercentage}%`} stopOpacity=\"1\" />\n                    <stop offset=\"100%\" stopOpacity=\"1\" />\n                  </>\n                )}\n              </linearGradient>\n              \n              {/* Combined gradient */}\n              <linearGradient id=\"maskedFill\" x1=\"0\" y1=\"0\" x2=\"0\" y2=\"1\">\n                <stop offset=\"5%\" stopColor=\"var(--primary)\" stopOpacity={0.3} />\n                <stop offset=\"95%\" stopColor=\"var(--primary)\" stopOpacity={0.05} />\n              </linearGradient>\n              \n              <mask id=\"thresholdMask\">\n                <rect x=\"0\" y=\"0\" width=\"100%\" height=\"100%\" fill=\"url(#fillMask)\" />\n              </mask>\n            </defs>\n            <CartesianGrid strokeDasharray=\"3 3\" stroke=\"#e5e7eb\" />\n            <XAxis\n              dataKey=\"value\"\n              type=\"number\"\n              scale={logScale ? 'log' : 'linear'}\n              domain={[minValue, maxValue]}\n              ticks={xAxisTickValues}\n              tickFormatter={(value) => value.toFixed(0)}\n              tick={{ fill: '#6b7280', fontSize: 12 }}\n            />\n            <YAxis\n              tick={{ fill: '#6b7280', fontSize: 12 }}\n            />\n            <Tooltip\n              cursor={{ stroke: 'var(--muted-foreground)', strokeDasharray: 4 }}\n              content={renderTooltip ?? (({ active, payload, label }) => {\n                if (!active || !payload || payload.length === 0) return null;\n                const first = payload[0];\n                const count = Number(first?.value ?? 0);\n                const valueLabel = typeof label === 'number' ? label.toFixed(2) : String(label ?? '');\n                return (\n                  <div\n                    className=\"rounded-md shadow-sm\"\n                    style={{\n                      background: 'var(--popover)',\n                      border: '1px solid var(--border)',\n                      color: 'var(--popover-foreground)',\n                      padding: '8px 10px',\n                      fontSize: 12,\n                    }}\n                  >\n                    <div className=\"font-medium\">Value: {valueLabel}</div>\n                    <div>Count: {count}</div>\n                  </div>\n                );\n              })}\n            />\n            {/* Filled area based on filter mode - render first */}\n            <Area\n              type=\"monotone\"\n              dataKey=\"count\"\n              stroke=\"none\"\n              fill=\"url(#maskedFill)\"\n              isAnimationActive={false}\n              style={{\n                clipPath: (filterMode === 'lt' || filterMode === 'lte')\n                  ? `inset(0 ${100 - thresholdPercentage}% 0 0)`\n                  : `inset(0 0 0 ${thresholdPercentage}%)`\n              }}\n            />\n            {/* Main outline - render on top for visibility */}\n            <Area\n              type=\"monotone\"\n              dataKey=\"count\"\n              stroke=\"var(--primary)\"\n              strokeWidth={2}\n              fill=\"none\"\n              isAnimationActive={false}\n            />\n            \n            {/* Threshold line using Recharts ReferenceLine for accurate positioning */}\n            <ReferenceLine\n              x={threshold}\n              stroke={thresholdColor}\n              strokeWidth={2}\n              strokeOpacity={0.8}\n              label={(props: unknown) => (\n                <ThresholdLabel\n                  {...(props as object)}\n                  count={currentCount}\n                  total={values.length}\n                  thresholdColor={thresholdColor}\n                  onMouseDown={handleMouseDown}\n                  showLabel={showThresholdLabel}\n                />\n              )}\n            />\n          </AreaChart>\n        </ResponsiveContainer>\n      </div>\n\n      {/* Value display (non-interactive to avoid blocking nearby controls) */}\n      <div className=\"absolute bottom-0 left-0 right-0 flex justify-between text-xs text-muted-foreground px-1 pointer-events-none\">\n        <span>{minValue.toFixed(0)}</span>\n        <span className=\"font-medium text-foreground\">\n          {filterMode === 'lt' && '< '}\n          {filterMode === 'lte' && '≤ '}\n          {filterMode === 'gt' && '> '}\n          {filterMode === 'gte' && '≥ '}\n          {threshold.toFixed(2)}\n        </span>\n        <span>{maxValue.toFixed(0)}</span>\n      </div>\n    </div>\n  );\n}\n",
      "type": "registry:ui",
      "target": "components/ui/cumulative-density-filter.tsx"
    },
    {
      "path": "lib/cumulative-utils.ts",
      "content": "export type FilterMode = 'lt' | 'lte' | 'gt' | 'gte'\n\nexport function lowerBound(arr: number[], x: number): number {\n  let l = 0, r = arr.length\n  while (l < r) {\n    const m = (l + r) >> 1\n    if (arr[m]! < x) l = m + 1\n    else r = m\n  }\n  return l\n}\n\nexport function upperBound(arr: number[], x: number): number {\n  let l = 0, r = arr.length\n  while (l < r) {\n    const m = (l + r) >> 1\n    if (arr[m]! <= x) l = m + 1\n    else r = m\n  }\n  return l\n}\n\nexport function getCountAtThreshold(mode: FilterMode, sortedValues: number[], t: number): number {\n  if (!sortedValues.length) return 0\n  switch (mode) {\n    case 'lt':\n      return lowerBound(sortedValues, t)\n    case 'lte':\n      return upperBound(sortedValues, t)\n    case 'gt': {\n      const i = upperBound(sortedValues, t)\n      return Math.max(0, sortedValues.length - i)\n    }\n    case 'gte': {\n      const i = lowerBound(sortedValues, t)\n      return Math.max(0, sortedValues.length - i)\n    }\n    default:\n      return upperBound(sortedValues, t)\n  }\n}\n\nexport function thresholdToPercentage(min: number, max: number, t: number, logScale: boolean): number {\n  if (max === min) return 0\n  if (logScale && min > 0 && max > 0 && t > 0) {\n    const logMin = Math.log(min)\n    const logMax = Math.log(max)\n    const logT = Math.log(t)\n    return ((logT - logMin) / (logMax - logMin)) * 100\n  }\n  return ((t - min) / (max - min)) * 100\n}\n\nexport function computeTicks(\n  minValue: number,\n  maxValue: number,\n  logScale: boolean,\n  containerWidth: number,\n  xAxisTicks?: number\n): number[] | undefined {\n  if (maxValue === minValue) return undefined\n  const autoTickCount = Math.max(6, Math.round((containerWidth || 0) / 40))\n  const count = xAxisTicks ?? autoTickCount\n  if (!count || count < 2) return undefined\n\n  const ticks: number[] = []\n  if (logScale && minValue > 0) {\n    const logMin = Math.log(minValue)\n    const logMax = Math.log(maxValue)\n    for (let i = 0; i < count; i++) {\n      const logValue = logMin + (i / (count - 1)) * (logMax - logMin)\n      ticks.push(Math.exp(logValue))\n    }\n  } else {\n    for (let i = 0; i < count; i++) {\n      ticks.push(minValue + (i / (count - 1)) * (maxValue - minValue))\n    }\n  }\n  return ticks\n}\n\n",
      "type": "registry:lib",
      "target": "lib/cumulative-utils.ts"
    }
  ],
  "tailwind": {
    "config": {
      "theme": {
        "extend": {}
      }
    }
  }
}